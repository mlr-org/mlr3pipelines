---
title: "Showcase: Branching"
author: "Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  collapse = TRUE,
  comment = "#>"
)
set.seed(8008135)
```

## Branching and Unbranching

Consider a scenario, in which there are different options for a given modeling step.
A researcher might, in an initial step want to try different options for this.
This can be done by specifying **branching** and **unbranching** operators.
In the long term, this also allows us to tune over the whole space, i.e. we learn which preprocessing option makes sense
for our data.

We will investigate the inner workings of such a Graph.
In this example we consider three options for preprocessing our data before we train a model. 

In a first step we define the different preprocessing steps:
We will consider scaling the data, transforming it using PCA, or not transforming the data at all (using `PipeOpNULL`).
```r
op1 = PipeOpScale$new()
op2 = PipeOpPCA$new()
op3 = PipeOpNULL$new()
opts = gunion(list(op1, op2, op3))
```
Additionally, we create the learner `PipeOp`.

```Å• 
polrn = PipeOpLearner$new(mlr_learners$get("rpart"))
```

In order to create a mental image of our Pipeline, we have to consider, how the data flows through our 
computational graph. In case we simply want  to do scaling, our pipeline would look like this: 

```r
op1 %>>% polrn
```
If we want to actively select one `PipeOp` in a set, we need to add a `PipeOp` that orchestrates the selection of
the following `PipeOp` using `PipeOpBranch`. After choosing one `PipeOp`, all not-selected operators simply recieve
a `NO_OP` object. 
We can now collect the activated/deactivated `PipeOp`s again using `PipeOpUnBranch`. 
This will become clearer in a short example.

### PipeOpBranch

We create a `PipeOpBranch` that let's us select one of
the following $3$ operators. We have to initialize 
this `PipeOp` with the number of output branches.

```r
po_b = PipeOpBranch$new(3)
```

This can be connected to the different preprocessing features.

```r
g = po_b %>>% opts
```

### PipeOpUnbranch

In order to collect the different inputs again, we use the 
`PipeOpUnbranch` operator. Again, we have to initialize this 
operator with the number of inputs it expects.

```r
po_ub = PipeOpUnbranch$new(3)
```
```r
g = g %>>% po_ub
```

We can visualize the resulting graph before diving into a
more detailed explanation.

```r
g$plot()
```
