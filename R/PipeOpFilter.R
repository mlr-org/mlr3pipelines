#' @title PipeOpFilter
#'
#' @name mlr_pipeop_filter
#' @format [`R6Class`] object inheriting from [`PipeOpTaskPreprocSimple`].
#'
#' @description
#' Feature filtering using a [`mlr3filters::Filter`] object, see the
#' \CRANpkg{mlr3filters} package.
#'
#' If a `Filter` can only operate on a subset of columns based on column type, then only these features are considered.
#' `nfeat` and `frac` will count for the features of the type that the `Filter` can operate on;
#' this means e.g. that setting `nfeat` to 0 will only remove features of the type that the `Filter` can work with.
#'
#' @section Methods:
#' * `PipeOpFilter$new(filter, id = filter$id, param_vals = list())` \cr
#'   ([`mlr3filters::Filter`], `character(1)`, `list`) -> `self` \cr
#'   Constructor. `filter` gives the `Filter` to use.
#'
#' @section Parameter Set:
#' * `settings` :: named `list()` \cr
#'   List of settings to be given to the `Filter`.
#'
#' * `nfeat`    :: `numeric(1)` \cr
#'   Number of features to select.
#'   Mutually exclusive with `frac` and `cutoff`.
#'
#' * `frac`     :: `numeric(1)` \cr
#'   Fraction of features to keep.
#'   Mutually exclusive with `nfeat` and `cutoff`.
#'
#' * `cutoff`   :: `numeric(1)` \cr
#'   Minimum value of filter heuristic for which to keep features.
#'   Mutually exclusive with `nfeat` and `frac`.
#'
#' @family PipeOps
#' @include PipeOpTaskPreproc.R
#' @export
#' @examples
#' # setup PipeOpFilter to keep the 5 most important
#' # features of the spam task w.r.t. their AUC
#' task = mlr3::mlr_tasks$get("spam")
#' filter = mlr3filters::mlr_filters$get("auc")
#' po = mlr_pipeops$get("filter", filter = filter)
#' po$param_set
#' po$param_set$values = list(filter.nfeat = 5)
#'
#' # filter the task
#' filtered_task = po$train(list(task = task))[[1]]
#'
#' # filtered task + extracted AUC scores
#' filtered_task$feature_names
#' head(po$state$scores, 10)
PipeOpFilter = R6Class("PipeOpFilter",
  inherit = PipeOpTaskPreprocSimple,
  public = list(
    filter = NULL,
    initialize = function(filter, id = filter$id, param_vals = list()) {
      assert_class(filter, "Filter")
      self$filter = filter$clone(deep = TRUE)
      self$filter$param_set$set_id = ""
      ps = ParamSet$new(list(
        ParamInt$new("nfeat", lower = 0),
        ParamDbl$new("frac", lower = 0, upper = 1),
        ParamDbl$new("cutoff")
      ))
      private$.outer_param_set = ps$add(filter$param_set)
      private$.outer_param_set$set_id = "filter"
      super$initialize(id, self$param_set, param_vals = param_vals)
    },

    get_state = function(task) {

      on.exit({
        self$filter$scores = structure(numeric(0), .Names = character(0))
      })
      filtercrit = c("nfeat", "frac", "cutoff")
      filtercrit = Filter(function(name) !is.null(private$.outer_param_set$values[[name]]), filtercrit)
      if (length(filtercrit) != 1) {
        stopf("Exactly one of 'nfeat', 'frac', 'cutoff' must be given. Instead given: %s",
          if (length(filtercrit) == 0) "none" else str_collapse(filtercrit))
      }
      critvalue = private$.outer_param_set$values[[filtercrit]]

      filtertask = task$clone()
      filtertask$select(filtertask$feature_types[get("type") %in% self$filter$feature_types, get("id")])

      self$filter$calculate(filtertask)
      scores = self$filter$scores

      features = switch(filtercrit,
        cutoff = names(scores)[scores >= critvalue],
        nfeat = head(names(scores), critvalue),
        frac = names(scores)[seq_len(round(length(filtertask$feature_names) * critvalue))],
        stop("unknown filter criterion"))

      # the features only relate to the features in `filtertask`, we want a vector of *all* features to keep
      features = setdiff(task$feature_names, setdiff(filtertask$feature_names, features))

      # we don't use 'scores', but maybe the user cares.
      # In particular, the user can *not* rely on the self$filter object being set, because
      # `$state` is the only place that the user may rely on being changed after `$traion()`.
      list(scores = scores, features = features)
    },

    transform = function(task) {
      task$select(self$state$features)
    }
  ),
  active = list(
    param_set = function(val) {
      if (is.null(private$.param_set)) {
        private$.param_set = ParamSetCollection$new(list(
          private$.outer_param_set,
          self$filter$param_set
        ))
        private$.param_set$set_id = self$id %??% self$filter$id # self$id may be NULL during initialize() call
      }
      if (!missing(val) && !identical(val, private$.param_set)) {
        stop("param_set is read-only.")
      }
      private$.param_set
    }
  ),
  private = list(
    deep_clone = function(name, value) {
      private$.param_set = NULL # required to keep clone identical to original, otherwise tests get really ugly
      if (is.environment(value) && !is.null(value[[".__enclos_env__"]])) {
        return(value$clone(deep = TRUE))
      }
      value
    },
    .outer_param_set = NULL
  )
)

mlr_pipeops$add("filter", PipeOpFilter, list(R6Class("Filter", public = list(id = "dummyfilter", param_set = ParamSet$new()))$new()))
