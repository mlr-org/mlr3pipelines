% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Graph.R
\docType{data}
\name{Graph}
\alias{Graph}
\title{Graph}
\format{\link{R6Class} Graph}
\usage{
Graph
}
\description{
The graph is a container class for the complete computational graph. It is made up of a list of
(connected) GraphNodes, it can be trained and used for prediction.
}
\section{Public Members / Active Bindings}{

\itemize{
\item \code{param_set}        ::  \link{ParamSet} \cr
Set of all exposed parameters of the graph, a union of all \code{param_set} objects of all contained \link{PipeOp} objects.
Parameter IDs are prefixed by PipeOp ID. Returns a deep-copy of all param sets.
\item \code{param_vals}         ::  named \code{list}
Set of all configured parameters of the graph, a union of all \code{param_vals} objects of all contained \link{PipeOp} objects. Parameter IDs are prefixed by PipeOp ID.
\item \code{packages}         :: \code{character}
Set of all required packages of the graph, a union of all required packages of all contained \link{PipeOp} objects.
\item \code{node_list}      :: list of \link{GraphNode}` \cr
Contains all nodes contained in the Graph, topologically sorted.
\item \code{is_trained}     :: \code{logical(1)} \cr
Is the graph, are all of its PipeOps, fully trained - and is the graph ready to predict?
\item \code{intype}         :: \code{list} \cr
Types of the \code{in_channels}, identifies types for the ingoing channels of nodes that are not connected yet.
\item \code{outtype}        :: \code{list of any} \cr
Types of the \code{out_channels}, identifies types for the outgoing channels of nodes that are not connected yet.
\item \code{in_channels}    :: \code{list of [NodeChannel]} \cr
Incoming NodeChannels of nodes that are not connected yet.
\item \code{out_channels}   :: \code{list of [NodeChannel]} \cr
Outgoing NodeChannels of nodes that are not connected yet.
\item \code{lhs}   ::  list of \link{GraphNode}` \cr
The 'left-hand-side' nodes that have some unconnected input channels and therefore act as graph input layer.
\item \code{rhs}     :: \code{list of [GraphNode]} \cr
The 'right-hand-side' nodes that have some unconnected output channels and therefore act as graph output layer.
}
}

\section{Methods}{

\itemize{
\item \code{new(fill = NULL)} \cr
(\code{\link{Graph}} | \code{NULL} | \code{\link{PipeOp}}) -> \link{Graph}
Constructs an empty Graph, copies an existing graph if \code{fill} is a graph, or fills graph
with node(s) if \code{fill} is a PipeOp. \code{fill} can also be a list of multiple Graphs / PipeOps.
\item \code{f$add_node(node)} \cr
(\code{\link{GraphNode}} | \code{\link{PipeOp}}) -> \link{Graph}
Mutates graph by adding a \link{PipeOp} or \link{GraphNode} to the end of the graph.
\item \code{extend(g)} \cr
(\link{Graph} | PipeOp | list f \link{Graph}) -> \code{self}
Add to the current graph per disjoint union.
\item \code{f$map(fnc, simplify)} \cr
\code{function}, \code{logical} -> 'list'
Maps function over all graph nodes, returns a list, named by \link{PipeOp} ids.
\item \code{f$train()}
Train graph on its inputs, ensure that after that all nodes are trained and that an output list is present.
\item \code{f$predict()}
Predict graph on its inputs, ensure that after that an output list is present.
\item \code{f$plot()}
Plot the graph, via igraph.
\item \code{f$print()}
Print a minimal representaion of graph on console.
\item get_pipeop
list of \link{GraphNode}, indexed by ID.
\item \code{f[[}: Get a PipeOp by \code{[[id]]}
}
}

\concept{Graph}
\keyword{datasets}
